# Event Horizon

## Background
This game is a 2d top-down shoot'em up game, in which the goal is to survive as long as possible until you are defeated. To break this game down,
the game is rendered utilizing HTML5 Canvas as well as object-oriented 
programming with JavaScript. The result is an attempt to replicate an arcade-style
top down shoot'em up kind of game.

Try it out here: [Event Horizon](https://spencer-jlee.github.io/Event-Horizon/)

## Assets Used

<a href="https://www.freepik.com/vectors/background">Background vector created by freepik - www.freepik.com</a>

<a href="https://deep-fold.itch.io/space-background-generator">Space background generated by Deep-Fold</a>

<a href="https://cingulari.itch.io/ignited-consumables-1">Health and ammo pickups were created by CingularI</a>

<a href="https://penusbmic.itch.io/sci-fi-character-pack-12">Player sprites were created by Penusbmic</a>

<a href="https://penusbmic.itch.io/sci-fi-character-pack-10">Enemy sprites were created by Penusbmic</a>

## Technologies, Libraries, APIs
This project was implemented with the following technologies:

* The Canvas API was used to render the game and its current state
* Vanilla JavaScript DOM was used to create actions for specific keybinds
* npm to manage project dependencies
* Babel/Webpack

## Gameplay

![Gameplay](/images/gameplay.gif)

The player character can move in any 2D direction and it can shoot based upon at the location of the cursor.
Enemies will spawn and over time, they will become more dangerous and more of them will appear to replace the ones that are defeated.
The player will have a health-bar and the game will end when the player's health is 0.

The player character will have multiple weapons and each weapon will have a specific ammo associated with it. 
If a player uses a certain weapon too much, the ammo count will reach 0 and the player cannot use it anymore.
There will be ways of replenishing ammo and health in this game through pickups
dropped by defeated enemies. 

## Functionality & MVPs
With this project, users will be able to do the following actions:

* Start and pause the game
* Move their character using specific keybinds
* Shoot in the direction of their cursor
* Switch between weapons

## Bonus Features
* Adding waves/rounds mechanics in which a player has to finish a wave before proceeding to the next round
* Add music and sound effects to the game.
* This list is not complete and this game can built in different directions.

## Code Snippets

### Unit Collision Logic:

```javascript
checkCollisions(){
    let objs = this.allObjects();
    //all entities (players, enemies, projectiles, pickups) are in the objects array
    for(let i = 0; i < objs.length; i++){
        for(let j = i+1; j < objs.length; j++){
            //checks if the radii of each of the two objects overlaps
            if(objs[i].isCollidedWith(objs[j])){
                if((objs[i] instanceof Projectile && objs[j] instanceof Enemy)
                || (objs[i] instanceof Enemy && objs[j] instanceof Projectile)){
                    //if objs[i] is an enemy and objs[j] is a projectile, the projectile is removed and the enemy is dealt damage
                    if(objs[i] instanceof Enemy){
                        this.checkEnemy(objs[i], objs[j]);
                    }

                    //cases below handle different projectiles fired
                    else if(objs[i] instanceof Ray){
                        
                    }

                    else{
                        this.remove(objs[i]);
                        this.createExplosion(objs[i]);
                    }
                    //same logic as above, but if objs[j] was the enemy and objs[i] was the projectile
                    if(objs[j] instanceof Enemy){
                        this.checkEnemy(objs[j], objs[i]);
                    }
                    else if(objs[j] instanceof Ray){
                        
                    }
                    else{
                        this.remove(objs[j]);
                        this.createExplosion(objs[j]);
                    }
                }
                // handles the logic of an ammo pickup and player collision
                else if((objs[i] instanceof Player && objs[j] instanceof Ammunition)
                || (objs[i] instanceof Ammunition && objs[j] instanceof Player)){
                    // the ammo pickup is removed
                    if(objs[i] instanceof Ammunition){
                        this.remove(objs[i]);
                    }
                    else if(objs[j] instanceof Ammunition){
                        this.remove(objs[j]);
                    }

                    let maxAmmo = this.player.maxAmmo[this.player.weaponIdx];
                    // checks if the difficulty modifier is applied
                    if(this.lessPickup){
                        this.player.ammo[this.player.weaponIdx] += Math.floor(maxAmmo * 0.1);
                    }
                    else{
                        this.player.ammo[this.player.weaponIdx] += Math.floor(maxAmmo * 0.2);
                    }
                    // cannot restore ammo more than max ammo of a given projectile
                    if(this.player.ammo[this.player.weaponIdx] > maxAmmo){
                        this.player.ammo[this.player.weaponIdx] = maxAmmo;
                    }
                }

                // handles logic of health pickup and player
                else if((objs[i] instanceof Player && objs[j] instanceof Health)
                || (objs[i] instanceof Health && objs[j] instanceof Player)){
                    //removes health pickup on collision
                    if(objs[i] instanceof Health){
                        this.remove(objs[i])
                    }
                    else if(objs[j] instanceof Health){
                        this.remove(objs[j]);
                    }

                    //checks if difficult modifier of less is applied
                    if(this.lessPickup){
                        this.player.health += 5;
                    }
                    else{
                        this.player.health += 10;
                    }
                    
                    //cannot restore more than max health
                    if(this.player.health > 100){
                        this.player.health = 100;
                    }

                }

                // handles logic of player and enemy collision
                else if((objs[i] instanceof Player && objs[j] instanceof Enemy)
                || (objs[i] instanceof Enemy && objs[j] instanceof Player)){
                    // changes the positions of the player and enemy once they collide
                    this.resetPositions(objs[i]);
                    this.resetPositions(objs[j]);

                    // once an enemy has collied with enemy, they cannot damage the player again for a period of time
                    if(objs[i] instanceof Enemy){
                        objs[i].hitstun = true;
                        objs[i].vel[0] *= -0.5 / objs[i].speed[objs[i].speedIdx];
                        objs[i].vel[1] *= -0.5 / objs[i].speed[objs[i].speedIdx];
                    }
                    else if(objs[j] instanceof Enemy){
                        objs[j].hitstun = true;
                        objs[j].vel[0] *= -0.5 / objs[j].speed[objs[j].speedIdx];
                        objs[j].vel[1] *= -0.5 / objs[j].speed[objs[j].speedIdx];
                    }
                    //checks for difficult modifiers
                    if(this.doubleDamage){
                        this.player.health -= 2;
                    }
                    else if(!this.doubleDamage){
                        this.player.health -= 1;
                    }
                    
                    if(this.player.health <= 0){
                        this.gameOver = true;
                    }
                }
                // handles logic of enemies colliding
                else if(objs[i] instanceof Enemy && objs[j] instanceof Enemy){
                    let enemy1 = objs[i];
                    let enemy2 = objs[j];
                    // similar logic to player enemy collision in which the enemies move apart
                    this.resetPositions(enemy1);
                    this.resetPositions(enemy2);
                    enemy1.hitstun = true;
                    enemy2.hitstun = true;
                    enemy1.vel[0] *= -0.5 / enemy1.speed[enemy1.speedIdx];
                    enemy2.vel[0] *= 0.5 / enemy2.speed[enemy2.speedIdx];
                    enemy1.vel[1] *= -0.5 / enemy1.speed[enemy1.speedIdx];
                    enemy2.vel[1] *= 0.5 / enemy2.speed[enemy2.speedIdx];
                }
            }

        }
    }
    }

    resetPositions(obj){
        if(obj.vel[0] < 0){
            obj.pos[0] -= obj.vel[0] - 1;
        }
        else{
            obj.pos[0] -= obj.vel[0] + 1;
        }
        if(obj.vel[1] < 0){
            obj.pos[1] -= obj.vel[1] - 1;
        }
        else{
            obj.pos[1] -= obj.vel[1] + 1;
        }
    }

    checkEnemy(enemy, projectile){
        if(projectile instanceof Single){
            enemy.health -= DAMAGE[0];
            this.score += DAMAGE[0] * 10;
        }

        else if(projectile instanceof Spread){
            enemy.health -= DAMAGE[1];
            this.score += DAMAGE[1] * 10;
        }

        else if(projectile instanceof Ray){
            enemy.health -= DAMAGE[2];
            this.score += DAMAGE[2] * 10;
        }

        else if(projectile instanceof Big){
            enemy.health -= DAMAGE[3];
            this.score += DAMAGE[3] * 10;
        }
        else{
            enemy.health -= DAMAGE[4];
            this.score += DAMAGE[4] * 10;
        }

        if(enemy.health <= 0){
            this.remove(enemy);
            this.score += 100;
            this.createPickup(enemy.pos);
        }
    }

    remove(obj){
        if(obj instanceof Enemy){
            this.enemies.splice(this.enemies.indexOf(obj), 1)
        }
        else if(obj instanceof Projectile){
            this.projectiles.splice(this.projectiles.indexOf(obj), 1)
        }
        else if(obj instanceof Health || obj instanceof Ammunition){
            this.pickups.splice(this.pickups.indexOf(obj), 1)
        }
    }

    createExplosion(obj){
        if(obj instanceof Big){
            for(let i = 0; i < 6; i++){
                let proj = new Projectile(obj.pos, 
                    [Math.random() * 6 - 3, Math.random() * 6 - 3],
                    2, "white", this);
                this.projectiles.push(proj);
            }
        }
    }
```


```javascript
//all objects have isCollidedWith
isCollidedWith(otherObject){
    let x_diff = otherObject.pos[0] - this.pos[0];
    let y_diff = otherObject.pos[1] - this.pos[1];

    let dist = Math.sqrt(Math.pow(x_diff, 2) + Math.pow(y_diff, 2));
    let radiiSum = this.radius + otherObject.radius;

    return dist <= radiiSum;
}
```

### Shooting Logic

```javascript
shoot(eventPos){
    //checks if there's available ammo of the selected weapon
    if(this.ammo[this.weaponIdx] > 0){
        let projVel = this.getVel(eventPos, this.pos);
        let proj;
        //if the spread weapon is selected, once fired, new projectiles are created are at different angles of the first projectile
        if(this.weaponIdx === 1){
            proj = new Spread(this.pos, projVel, this.game);
            let vel1 = this.calcVel(projVel, "left");
            let vel2 = this.calcVel(projVel, "right");
            let proj1 = new Spread(this.pos, vel1, this.game);
            let proj2 = new Spread(this.pos, vel2, this.game);
            this.game.addObject(proj1);
            this.game.addObject(proj2);
        }
        //creates projectiles for other weapons
        else if(this.weaponIdx === 2){
            proj = new Ray(this.pos, projVel, this.game);
        }
        else if(this.weaponIdx === 3){
            proj = new Big(this.pos, projVel, this.game);
        }
        else{
            proj = new Single(this.pos, projVel, this.game);
        }
        this.game.addObject(proj);
        this.ammo[this.weaponIdx] -= 1;
    }
}

//gets the position of where the mouse is clicked
getVel(clickPos, playerPos){
    let x = clickPos[0] - playerPos[0];
    let y = clickPos[1] - playerPos[1];
    //determines the x and y velocities of the projectile that is fired
    let xVel = SPEEDS[this.weaponIdx] * (x / Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)));
    let yVel = SPEEDS[this.weaponIdx] * (y / Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)));

    return [xVel, yVel];
}

//calculates the angles of the two other projectiles fired in the spread weapon
calcVel(projVel, direction){
    //gets the x and y velocities of the projectile fired
    let unitSpeedX = projVel[0] / SPEEDS[this.weaponIdx];
    let unitSpeedY = projVel[1] / SPEEDS[this.weaponIdx];
    //determines the angle of which other two projectiles is fired
    let thetaX = Math.asin(unitSpeedX);
    let thetaY = Math.acos(unitSpeedY);
    let newVelX, newVelY;
    //changes based upon where the projectile should be fired relative to the original
    if(direction === "right"){
        newVelX = SPEEDS[this.weaponIdx] * Math.sin(thetaX + (Math.PI / 12));
        newVelY = SPEEDS[this.weaponIdx] * Math.cos(thetaY + (Math.PI / 12));
    }
    else if(direction === "left"){
        newVelX = SPEEDS[this.weaponIdx] * Math.sin(thetaX - (Math.PI / 12));
        newVelY = SPEEDS[this.weaponIdx] * Math.cos(thetaY - (Math.PI / 12));
    }
    
    
    return [newVelX, newVelY];
}
```